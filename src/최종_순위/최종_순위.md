[3665번 최종 순위](https://www.acmicpc.net/problem/3665)

### 문제 요약

$n$개의 팀에 순위가 주어집니다.\
$m$개의 서로 다른 두 팀간의 상대적인 순위 변경이 입력으로 주어집니다.\
예를 들면 2팀이 3팀보다 높은 순위였는데, (3, 2)가 입력으로 주어진다면 변경된 순위는 3팀이 2팀보다 높은 순위가 됩니다.\
변경된 순위를 출력하세요. 변경된 순위가 올바르지 않다면 `IMPOSSIBLE`을 출력하세요.

$2 ≤ n ≤ 500$\
$0 ≤ m ≤ 25000$

## 생각

### 1. 그래프 (LinkedList)

순위와 관련된 문제는 대부분 그래프 자료구조 이용해서 해결할 수 있기 때문에, 그래프 문제라고 생각했습니다.\
Team 오브젝트를 만들어서, 현재 팀보다 순위가 높은 팀들을 저장하고, 현재 팀보다 순위가 낮은 팀을 하나 가리키도록 했습니다.

```java
static class Team implements Comparable<Team> {

	public Team(int name, int rank) {
		this.name = name;
		this.rank = rank;
		this.ref = new TreeSet<>();
	}

	int name; // 5팀이 1순위라면 name = 5
	int rank; // 5팀이 1순위라면 rank = 1
	Team next; // 이 팀보다 순위가 낮은 팀
	TreeSet<Team> ref; // 이 팀을 가리키는, 즉 이 팀보다 순위가 높은 팀

	@Override
	public int compareTo(Team o) {
		return this.rank - o.rank;
	}
}
```

높은 순위였던 `A`와 낮은 순위였던 `B`의 순위가 바뀌는 경우를 예시로 들면,

1. `B.next`의 `ref`에서 `B`를 제거합니다. (`B.next`는 B보다 낮은 순위의 팀)
2. `B.ref.next`를 `B.next`로 설정합니다. (`B`보다 높은 순위의 팀들의 아래 순위 팀을 `B.next`로 설정)
3. `B.next`를 `A`로 설정합니다.
4. `A.ref`에 `B`를 추가합니다.

이렇게 계산한 그래프를 탐색하면서, 더 높은 순위의 팀이 없을 때(`ref`가 비어있을 때) 해당 팀을 출력하도록 했습니다.

**문제** <br>

이렇게 했을 때 문제는, `B`가 변경되었을 때 `B`보다 높은 순위의 팀에 대한 정보, 즉 `B.ref`를 제대로 설정할 수 없습니다.\
만약 `B.ref`를 초기화하면, `ref`가 0인 팀이 여러 개 생기게 되고, 그 중에서 기존 우선순위가 높았던 팀을 높은 순위로 선정해야합니다.\
PriorityQueue를 이용해서 기존 우선순위에 따라 먼저 선정할 팀을 골랐지만, 한 팀이 여러 팀과 순위가 변경되는 경우를 제대로 처리할 수 없었습니다.

<br>

### 2. 그래프 (인접 행렬)

자신보다 낮은 팀을 모두 연결하는 그래프를 그리면 위의 문제는 해결됩니다.\
생각을 단순화하기 위해서 인접 행렬`int[][] arr`로 그래프를 저장했습니다.

$$arr_{ij} = i\text{의 순위가 }j\text{의 순위보다 높다면 }1\text{, 아니면 }0$$

주어지는 순위가 `[5, 4, 3, 2, 1]` 일 때, `arr`는 다음과 같습니다.

|   | 1 | 2 | 3 | 4 | 5 |
|---|---|---|---|---|---|
| 1 | 0 | 0 | 0 | 0 | 0 |
| 2 | 1 | 0 | 0 | 0 | 0 |
| 3 | 1 | 1 | 0 | 0 | 0 |
| 4 | 1 | 1 | 1 | 0 | 0 |
| 5 | 1 | 1 | 1 | 1 | 0 |

자신보다 높은 순위에 있는 팀의 개수를 `int[] ref`에 저장합니다. `arr`이 위와 같다면 `ref`는 다음과 같습니다.

|     | 1 | 2 | 3 | 4 | 5 |
|-----|---|---|---|---|---|
| ref | 4 | 3 | 2 | 1 | 0 |

순위의 변경이 있다면, 그래프의 화살표의 방향을 바꿔줍니다.\
높은 순위였던 `4팀`과 낮은 순위였던 `2팀`의 순위가 바뀌는 경우를 예시로 들면,\
`4 -> 2`에서 `2 -> 4`로 화살표 방향을 변경해줍니다.\
변경 후 `arr`은 다음과 같아집니다.

|   | 1 | 2 | 3 | 4 | 5 |
|---|---|---|---|---|---|
| 1 | 0 | 0 | 0 | 0 | 0 |
| 2 | 1 | 0 | 0 | 1 | 0 |
| 3 | 1 | 1 | 0 | 0 | 0 |
| 4 | 1 | 0 | 1 | 0 | 0 |
| 5 | 1 | 1 | 1 | 1 | 0 |

변경 후 `ref`는 다음과 같습니다.

|     | 1 | 2 | 3 | 4 | 5 |
|-----|---|---|---|---|---|
| ref | 4 | 2 | 2 | 2 | 0 |

이렇게 변경에 대해서는 화살표 방향과 `ref`만 수정합니다.\
변경이 끝난 후에는 `ref`가 0인 팀(가장 높은 순위의 팀)을 찾아서 탐색을 시작합니다.\
`A`팀이 순위가 정해지고 제외되었다면, `A`보다 확실히 낮은 순위의 팀들은 `ref`를 감소시킵니다.\
`arr[A][B] = 1` 이라면, `B`는 `A`보다 확실하게 순위가 낮은 팀이므로 `B`의 `ref`를 감소시켜야 합니다.

올바른 순위라면 다음 팀을 선정하는 과정마다 `ref`를 감소시킨 후 `ref`가 0인 팀은 한 팀 존재해야하며, 그렇지 않은 경우에는 잘못된 순위가 됩니다. 예를 들면,

- `ref`가 0인 팀이 없다면 순위에 모순이 생긴 것이므로 잘못된 순위입니다.
- `ref`가 0인 팀이 2팀 이상이라면 순위를 구분할 수 없으므로 잘못된 순위입니다.

자신보다 낮은 팀을 모두 연결하는 그래프를 그리면 위상정렬로 쉽게 해결할 수 있는 문제였습니다.\
오랜만에 위상정렬 문제를 만나서 헤맸네요..
