[13344번 Chess Tournament](https://www.acmicpc.net/problem/13344)

### 문제 요약

N명의 플레이어가 M번의 체스 경기를 치루고, M개의 결과가 주어집니다.\
체스 경기는 실력이 높은 플레이어가 항상 이깁니다. 하지만 플레이어의 실력을 알 수는 없습니다.\
경기 결과는 플레이어가 보고하며, 일관되지 않은 결과가 있을 수도 있습니다.\
경기 결과의 일관성을 판별하세요.

$2 ≤ N ≤ 50,000$\
$1 ≤ M ≤ 250,000$

## 생각

### 1. Union find

플레이어 $A$, $B$가 비겼는지 판별하기 위해 Union find를 사용하여 저장했습니다.\
`eq = new int[N]`이고, `eq[A] == eq[B]` 라면 $A$와 $B$는 승패를 가릴 수 없고, 같은 클래스에 속한 것 입니다.

플레이어가 최대 50,000명이므로 인접 리스트 `ArrayList<Integer>[] arr`를 사용해서 승패 관계를 저장했습니다.

$$arr[A] = \text{플레이어 } A\text{가 이긴 플레이어 리스트}$$

그리고 경기 결과를 입력받는대로 일관성을 판별했습니다.

- $A$와 $B$가 비겼다면 Union으로 설정하고, `arr[A]`에 $B$가 있는지, `arr[B]`에 $A$가 있는지 검사했습니다.
- $A$가 이겼다면 `arr[A]`에 $B$를 추가하고, `arr[B]`에 $A$가 있는지 검사하고, Union 인지 검사했습니다.

검사에 통과했다면 일관성있고, 통과하지 못했다면 일관성이 없는 것입니다.\
하지만 이 로직에서는 군집화한 것의 이점을 살리지 못합니다.\
예를 들면, 다음과 같은 예제에서 문제가 발생합니다.

```
5 4
1 = 2
2 > 4
3 = 4
3 > 1
```

`1, 2`와 `3, 4`는 다른 클래스(서로 비긴 플레이어들의 군집)입니다.\
`1, 2`를 $X$ 클래스, `3, 4`는 $Y$ 클래스라고 하면, $X$에 속한 `2`가 $Y$의 `4`를 이겼지만, $Y$의 `3`은 $X$의 `1`을 이겼으므로 일관성이
없습니다.

1. 1 = 2\
   1과 2를 Union으로 설정하고, `arr[1]`에 2가 없고 `arr[2]`에 1이 없으므로 일관성이 있습니다.\
   `Union(1, 2)`
2. 2 > 4\
   `arr[2]`에 4를 추가하고, `arr[4]`에 2가 없고 2, 4는 Union이 아니므로 일관성이 있습니다.\
   `arr[2] = [4]`
3. 3 = 4\
   3과 4를 Union으로 설정하고, `arr[3]`에 4가 없고 `arr[4]`에 3이 없으므로 일관성이 있습니다.\
   `Union(3, 4)`
4. 3 > 1\
   `arr[3]`에 1을 추가하고, `arr[3]`에 1이 없고 1, 3은 Union이 아니므로 일관성이 있습니다.\
   `arr[3] = [1]`

이 방법대로라면 예제에 일관성이 없지만, 그것을 제대로 판별할 수 없습니다.\
깊은 depth를 탐색하여 결과 그래프의 사이클을 찾도록 로직을 수정하면 해결할 수 있습니다. 하지만 시간 내에 판별할 수 없다고 생각했습니다.

### 2. Union find + DFS

위의 로직을 플레이어 단위가 아닌 클래스 단위로 계산하면, 시간 내에 판별할 수 있습니다.

1. 먼저 비긴 플레이어들을 classify합니다.
2. 그 다음 클래스 간 승패 관계를 저장합니다.
3. 클래스 간 승패 관계 그래프를 탐색하면서, 사이클이 있는지 검사합니다.

$$arr[A] = \text{클래스 } A\text{가 이긴 클래스 리스트}$$

탐색 중 사이클이 발견되면 일관성이 없다고 판단하면 됩니다.\
사이클이 발견되지 않은 클래스는 다시 탐색하지 않도록 메모이제이션을 이용합니다.\
따라서 각 클래스를 한 번씩만 탐색하여 일관성을 판단할 수 있습니다.

위의 예제에서는 다음과 같이 진행됩니다.

1. 1 = 2
2. 3 = 4\
   `Union A(1, 2), Union B(3, 4)`
3. 2 > 4 (2는 Union A, 4는 Union B)
4. 3 > 1 (3은 Union B, 1은 Union A)\
   `arr[A] = [B], arr[B] = [A]`

그래프를 탐색하면, `A -> B -> A`로 사이클이 발견되어 일관성이 없다고 판단할 수 있습니다.

그래프를 탐색할 때 DFS를 사용했는데, 위상 정렬이나 BFS를 사용해도 동일한 결과가 나올 것이라고 예상됩니다.
